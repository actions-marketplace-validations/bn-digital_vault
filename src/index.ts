import { config } from 'dotenv'
import NodeVault, { client } from 'node-vault'
import path from 'path'
import fs from 'fs'
import { OptionValues } from 'commander'
import { cyan, green, red, yellow } from 'chalk'

const log = console.log
export type AuthProviders = 'github'

export type CommandLineArgs = OptionValues & {
  endpoint?: string
  token?: string
  dist?: string
  file?: string
  auth?: AuthProviders
}

export default class VaultEnv {
  private readonly vault: client
  private readonly client: Promise<client>

  /**
   * @param endpoint
   * @param auth
   */
  constructor(endpoint: string, auth: { provider: string; token: string }) {
    this.vault = NodeVault({ endpoint: endpoint })

    if (auth.provider === 'github') {
      this.client = this.vault.githubLogin({ token: auth.token })
    }
  }

  /**
   * Writes fetched secret values to file, using template file with env variable keys and secret paths as values
   * @param from
   * @param to
   */
  populate(from: string, to: string): void {
    const distPath = path.resolve(from)
    const envPath = path.resolve(to)
    const existingValues: { [key: string]: string } = fs.existsSync(envPath) ? config({ path: envPath }).parsed : {}
    fs.writeFileSync(envPath, '# Autogenerated by vault-env \n')
    if (distPath) {
      const template = config({ path: distPath }).parsed
      if (template) {
        Object.entries(template)
          .sort((a, b) => (a[0] > b[0] ? 1 : -1))
          .forEach(([key, value]) => {
            log(`Setting ${cyan(key)} from ${green(value)}`)
            this.readSecret(value).then((secret) =>
              secret
                ? fs.appendFile(envPath, `${key}=${secret}\n`, (error) => error && log(red(error)))
                : yellow(`Failed to fetch ${value}`)
            )
          })
      } else {
        log(red('No template provided'))
      }
      fs.writeFileSync(envPath, '# Custom variables \n')
      Object.entries(existingValues)
        .filter((it) => template[it[0]] === undefined)
        .forEach(([key, value]) => fs.appendFileSync(envPath, `${key}=${value}\n`))
    } else {
      throw new Error(`No template file available at ${distPath}`)
    }
  }

  /**
   * Reads secret by provided complete path to secret, including name, e.g. staging/database/username, where "staging" is key-value path
   * @param path
   */
  private async readSecret(path: string): Promise<string> {
    const chunks = path.split('/')
    const root = chunks.shift()
    const searchKey = chunks.pop()
    chunks.unshift(root, 'data')
    const secretPath = chunks.join('/')
    return await this.client
      .then(() => this.vault.read(secretPath))
      .then((secret) => secret.data.data[searchKey])
      .catch((reason) => log(red(reason)))
  }
}
